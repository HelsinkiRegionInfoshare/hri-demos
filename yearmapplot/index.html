<!doctype html>
<html>
<meta charset="utf-8" />
<head>
<title></title>

<script type="text/javascript" src="../vendor/jquery-1.11.0.js"></script>

<!-- IE hacks -->
<meta http-equiv="x-ua-compatible" content="IE=Edge"/>
<script type="text/javascript" src="../vendor/es5-shim.min.js"></script>
<script type="text/javascript" src="../vendor/jquery.xdomainrequest.min.js"></script>

<script type="text/javascript" src="../vendor/coffee-script.js"></script>
<script type="text/javascript" src="../vendor/underscore.js"></script>
<script type="text/javascript" src="../vendor/bootstrap/js/bootstrap.js"></script>
<script type="text/javascript" src="../vendor/bootstrap-multiselect.js"></script>
<script type="text/javascript" src="../vendor/jquery.flot.js"></script>
<script type="text/javascript" src="../vendor/jquery.flot.resize.js"></script>
<script type="text/javascript" src="../vendor/jquery-deparam.js"></script>
<script type="text/javascript" src="../vendor/jquery-ui/jquery-ui.min.js"></script>
<link rel="stylesheet" href="../vendor/jquery-ui/jquery-ui.css" />
<script type="text/javascript" src="../vendor/slider/js/bootstrap-slider.js"></script>
<link rel="stylesheet" href="../vendor/slider/css/slider.css" />
<script type="text/javascript" src="../vendor/spin.js"></script>
<script type="text/javascript" src="../vendor/jquery.spin.js"></script>
<link rel="stylesheet" href="../vendor/jquery.powertip/jquery.powertip.css" />
<script type="text/javascript" src="../vendor/jquery.powertip/jquery.powertip.js"></script>

<link rel="stylesheet" href="../vendor/leaflet.css" />
<script src="../vendor/leaflet.js"></script>
<script src="../vendor/proj4.js"></script>
<script src="../vendor/proj4leaflet.js"></script>
<script src="../vendor/leaflet-dvf.js"></script>
<script type="text/coffeescript" src="hel_map.coffee"></script>

<!-- Include the Statproxy class -->
<script type="text/coffeescript" src="../vendor/statproxy.coffee"></script>

<link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
<style type="text/css">
#map {
	height: 100%;
	width: 100%;
	background-color: white;
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	height: auto;
	width: auto;
}

#map .leaflet-control-scale {
	display: none;
}

#controls {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	z-index: 1;
}

#controls > * {
	background-color: rgba(255,255,255,0.9);
	padding: 10px;
}


#lineplot {
	height: 100%;
	width: 100%;
	background-color: rgba(255,255,255,0.9)
}

#lineplot-container {
	position: absolute;
	bottom: 10px;
	left: 10px;
	width: 500px;
	height: 300px;
}

#yearslider_container {
}

.dropdown-menu {
	max-width: 400px !important;
	overflow-x: auto !important;
}

.variable_label {
	display: block;
	font-weight: bold;
}

.plot_x_label,
.plot_y_label {
	font-size: small;
	font-weight: bold;
}


</style>

</head>
<body>

<div id="controls" class="container-fluid">
  <div class="row" id="variable_selectors">
    <h4 class="col-md-3" id="dataset_title"></h4>
    <div class="col-md-3 variable_selector" id="yearslider_container"></div>
  </div>
</div>

</table>



<div id="map">
</div>

<div id="lineplot-container">
  <div id="lineplot"></div>
</div>




<script type="text/coffeescript">
# URL to the JSON-"entrypoint" of the statistic.
# Any resource with a 'vuosi' field could be used here
STAT_RESOURCE="http://dev.hel.fi/stats/resources/aluesarjat_a01hki_asuntokuntien_tulot/"
GEOSERVER_BASE_URL = "http://geoserver.hel.fi/geoserver/"

# Get a "proxy object" to the resource
stats = new Statproxy STAT_RESOURCE

# Get the "specification" of the data. Includes
# metadata such as the title and dimensions/categories
# in the dataset.
spec_promise = stats.specification()

# Fetch the area polygons in GeoJSON format using WFS
wfs_url = GEOSERVER_BASE_URL + "wfs/"
request_parameters = {
    # Specify the dataset to use
    typeName: 'hel:osaalue'
    # Standard WFS request parameters
    srsName: 'EPSG:4326'
    service: 'WFS'
    version: '1.1.0'
    request: 'GetFeature'
    outputFormat: 'application/json'
    }
polygons_promise = $.getJSON(wfs_url, request_parameters)

class SelectionController
	constructor: (@specification) ->
		@selection = get_url_filtering()
		@$ = $ @
	
	update_selection: (dimension, category, enabled) =>
		if dimension not of @selection
			@selection[dimension] = {}
		
		if not enabled
			delete @selection[dimension][category]
		else
			@selection[dimension][category] = enabled

		# Update the selection to the url
		update_url_filtering @selection
		@trigger_change()
	
	set_selection: (dimension, categories) =>
		if not _.isArray categories
			categories = [categories]
		
		@selection[dimension] = {}
		for category in categories
			@selection[dimension][category] = true
		update_url_filtering @selection
		@trigger_change()
	
	toggle: (dimension, category) =>
		if dimension not of @selection
			@selection[dimension] = {}
		if category of @selection[dimension]
			delete @selection[dimension][category]
		else
			delete @selection[dimension][category] = true
		@trigger_change()
			
	
	trigger_change: =>
		@$.trigger 'selection_changed', [@selection, @has_full_selection]
		
	
	has_full_selection: (axes) =>
		# Check if we have at least one selection for
		# each dimension.
		for dim in @specification.dimensions
			dim_id = dim.id
			if dim_id in axes
				continue

			if dim_id not of @selection
				return false
			if _.isEmpty @selection[dim_id]
				return false
		return true
	

class PlotController
	constructor: (@el, @stats, @specification, @axes) ->
		@$el = $ @el
		@$el.draggable()
		@$el.resizable()
		# Use only horizontal labels, as they can be quite long
		# and don't wrap nicely when rotated. Yes, it's a table
		# for layouting.
		@$el.append $ """
		<table style="height: 100%; width: 100%;">
		<tr><td class="plot_y_label" style="text-align: center"></td></tr>
		<tr><td class="plot_container_cell" style="height: 100%; width: 100%;"></td></tr>
		<tr><td class="plot_x_label" style="text-align: center"></td></tr>
		</table>
		"""
		@plot_el = @$el.find(".plot_container_cell")[0]
		@xlabel_el = @$el.find(".plot_x_label")
		@ylabel_el = @$el.find(".plot_y_label")

		# Convert the specification to an object so it's
		# nicer to work with
		@dictspec = Statproxy.specification_to_object @specification
	
	refresh_data: (selection, is_full) =>
		@$el.spin()
		# Ensure we have at least one selection for
		# each dimension. Failing to do this will cause
		# a massive dataset, as without filtering, the
		# default is to return all results.
		if not is_full @axes
			@refresh_plot {}, []
			return

		my_selection = _.omit selection, @axes...
		# First filter for the selected categories
		substats = @stats.filter my_selection

		# The plot needs to know the selection of the data.
		# This may change as the fetching/drawing is still in progress,
		# so we'll have to deep-copy it.
		selection_clone = JSON.parse JSON.stringify my_selection

		# As we allow multiple categories to be selected
		# simultaneously, any category combination will
		# get its own line, so they need to be "grouped".
		# The server (and the proxy)
		# has a "group_for_columns" method for this.
		# Get the needed data and pass it to the plotter
		substats.group_for_columns(@axes).done (data) =>
			@refresh_plot selection_clone, data


	refresh_plot: (selection, data) =>
		# Check which dimensions are included in the label.
		# Use only the dimensions that have more than one
		# option selected.
		needs_labels = []
		y_axis_labels = []
		for dim_id, categories of selection
			if _.size(categories) > 1
				needs_labels.push dim_id
			else if _.size(categories) == 1
				dim = @dictspec.dimensions[dim_id]
				cat = dim.categories[(k for k of categories)[0]]
				y_axis_labels.push cat.label

		
		# Convert the data to a format that the plotting
		# library flot understands.
		datasets = []
		for group in data
			# Convert to numbers
			x = group[@axes[0]].map parseFloat
			y = group[@axes[1]].map parseFloat
			
			# Convert the data to "row-format"
			xy = _.zip x, y
			
			# Generate this group's plot label
			label = []
			for k in needs_labels
				dim = @dictspec.dimensions[k]
				label.push dim.categories[group[k]].label
			datasets.push
				data: xy
				label: label.join ' '
		
		
		@ylabel_el.text y_axis_labels.join ', '
		@xlabel_el.text @dictspec.dimensions[@axes[0]].label
		# And finally plot the datasets using flot
		$.plot @plot_el, datasets,
			series:
				lines: show: true
				points: show: true
			
		$(@el).spin(false)

class MapController
	constructor: (@el, @polygons, @stats, @specification, @axes,
			@selection_control, @tooltip_func=((feature) ->)
			) ->
		@$el = $ "#"+el
		@map = hel_leaflet_map @el,
			zoomControl: false
		new L.Control.Zoom({ position: 'topright' }).addTo(@map.map)
		@polygons_by_area = {}
		for polygon in @polygons.features
			# Convert the area_id to integer as the datasets
			# differ in these IDs
			# in whether they are zero-padded or not.
			# TODO: This could be taken as an argument in the
			#	constructor
			area_id = parseInt(polygon.properties.tunnus)
			polygon.properties.area_id = area_id
			@polygons_by_area[area_id] = polygon

		@layers_by_area = {}

		@borders_layer = L.geoJson polygons,
			onEachFeature: (feat, layer) =>
				return if 'area_id' not of feat.properties
				@layers_by_area[feat.properties.area_id] = layer

				layer.on click: (e) =>
					feat = e.target.feature
					return if 'raw_area' not of feat.properties
					raw_area = feat.properties.raw_area
					@selection_control.toggle @axes[0], raw_area


		@borders_layer.addTo @map.map
	
	refresh_data: (selection, is_full) =>
		@$el.spin()
		@$el.powerTip
			followMouse: true
			manual: true
		my_selection = _.omit selection, @axes...
		substats = @stats.filter my_selection
		selection_clone = JSON.parse JSON.stringify selection
		substats.group_for_columns(@axes).done (data) =>
			@refresh_plot selection_clone, data
	
	refresh_plot: (selection, data) =>
		enabled_polygons = []
		data = data[0]
		area_and_value = _.zip data[@axes[0]], data[@axes[1]]
		for [area, value] in area_and_value
			# Parse the "small-area-id" from the area string
			# Encoded as (zero padded) number of three digits
			# in the end. Zero if not 'small area'
			# TODO: This could be taken as an argument in the
			#	constructor
			area_id = area
			area_id = parseInt area_id[area_id.length-3...]
			continue if area_id == 0
			continue if area_id not of @polygons_by_area
			polygon = @polygons_by_area[area_id]
			polygon.properties.stat_value = parseFloat value
			polygon.properties.raw_area = area
			enabled_polygons.push polygon
		
		# Calculate the range and colormap from it
		all_values = (p.properties.stat_value for p in enabled_polygons \
			when not isNaN p.properties.stat_value)
		# Get rid of really extreme values
		
		all_values.sort((a, b) -> a - b)

		min_value = all_values[0]
		max_value = all_values[all_values.length-1]
		# Creates a green (highest) to red (lowest) colormap
		value_to_color = new L.HSLHueFunction(
			new L.Point(min_value,0),
			new L.Point(max_value,120))

		if @axes[0] of selection
			area_selection = selection[@axes[0]]
		else
			area_selection = {}
		
		styler = (polygon) =>
			# Get the value and force it in to the color mapping range
			value = polygon.properties.stat_value
			if value < min_value
				value = min_value
			if value > max_value
				value = max_value
			# Specify the styling and coloring by value
			color = value_to_color.evaluate(value)
			style =
				color: "white"
				fillColor: color
				fillOpacity: 0.7
				opacity: 1
				dashArray: '3'
				weight: 1

			if not value
				style.fillOpacity = 0.1
			
	
			layer = @layers_by_area[polygon.properties.area_id]
			
			if area_selection[polygon.properties.raw_area]
				style.weight = 3
				style.color = "black"
				style.dashArray = ''
				layer.bringToFront()
			
			layer.on "mouseover", (e) =>
				tooltip = @tooltip_func e.target.feature
				return if not tooltip
				@$el.data 'powertipjq', tooltip
				$.powerTip.show @$el
			layer.on "mouseout", (e) ->
				$.powerTip.hide @$el
			
			return style
		@borders_layer.setStyle styler
		@$el.spin(false)

# Set up the selection UI when we get the data
$.when(spec_promise, polygons_promise).done (args...) ->
	[spec, polygons] = (arg[0] for arg in args)
	selection = new SelectionController spec
	plot = new PlotController "#lineplot", stats, spec, ['vuosi', 'value']

	get_tooltip = (feature) ->
		prop = feature.properties
		return $ """
			<div>
			<h6>#{prop.nimi}</h6>
			#{prop.stat_value}
			</div>
			"""

	map = new MapController("map", polygons, stats, spec, ['alue', 'value'], selection, get_tooltip)
	
	
	# Set the title
	$("#dataset_title").html spec.metadata.label
	$("head title").html spec.metadata.label

	# Get "free" dimensions, eg on which we have
	# to select something
	free_dims = (dim for dim in spec.dimensions \
		when dim.id not in ['value', 'vuosi'])
	
	multiselect_dims = ['alue']
	
	# Helper function to get a label of a
	# dimension/category if it exists
	get_label = (obj) ->
		if 'label' of obj
			return obj.label
		return obj.id

	# Set up select boxes for the free variables
	selectors = $ "#variable_selectors"
	for dim in free_dims
		#container = $("<li></li>").appendTo selectors
		#selrow = container
		#selrow = selectors
		container = selectors
		selrow = $("""
			<div class="variable_selector col-md-3">
			  <span class="variable_label">#{get_label dim}</span>
			</div>
			""").appendTo container
		selector = $("""
		<select name="#{dim.id}">
		</select>
		""").appendTo selrow
		is_multiselect = dim.id in multiselect_dims
		
		# "Uniselect" selects first by default
		if not is_multiselect and dim.id not of selection.selection
			selection.set_selection dim.id, dim.categories[0].id
	
		# Synchronize the selection to the dropdowns
		selection.$.on 'selection_changed', do (dim, selector) -> (ev, args...) ->
			selector.find('option').removeAttr "selected"
			if dim.id not of selection.selection
				selector.multiselect "refresh"
				return
			for selected of selection.selection[dim.id]
				selector.find("option[value=\"#{selected}\"]").attr "selected", "selected"
			selector.multiselect "refresh"

		for cat in dim.categories
			optel = $("""
			<option value="#{cat.id}">
			#{get_label cat}
			</option>
			""").appendTo selector
			
		if is_multiselect
			selector.attr "multiple", "multiple"
			onChange = do (dim) -> (el, enabled) ->
				selection.update_selection dim.id, el.val(), enabled
		else
			onChange = do (dim) -> (el, enabled) ->
				return if not enabled
				selection.set_selection dim.id, el.val()
		

		selector.multiselect
			enableCaseInsensitiveFiltering: true
			onChange: onChange
			maxHeight: 300
			buttonWidth: "250px"
	
	for dim in spec.dimensions
		break if dim.id == 'vuosi'
	
	# Add year slider
	
	# "Select latest year by default
	selection.set_selection dim.id, dim.categories[dim.categories.length-1].id

	#labels.append $ "<th>#{get_label dim}</th>"
	selrow = $("#yearslider_container")
	$("""
	<span class="variable_label">#{get_label dim}</span>
	<input type="text" id="yearslider"></input>
	""").appendTo selrow

	years = (parseInt c.id for c in dim.categories)
	slider = selrow.find "#yearslider"
	slider.slider
		min: _.min years
		max: _.max years
		tooltip: 'always'
	
	slider.slider().on 'slide', do (dim) -> (ev) ->
		selection.set_selection dim.id, ev.value
	refresh_slider = ->
		value = _.keys(selection.selection['vuosi'])[0]
		slider.slider 'setValue', parseInt value
	
		
	# Hook up the objects to the selection
	selection.$.on 'selection_changed', (ev, args...) ->
		plot.refresh_data args...
		map.refresh_data args...
		refresh_slider()
	
	# And force initial change
	selection.trigger_change()


# A helper function to decode the "state"
# from an url. Using the hash for IE-compatibility :(
get_url_filtering = ->
	hash = window.location.hash
	state = $.deparam hash[1...]
	# Parse from the URL format to the actually used
	# format.
	for dim, catstr of state
		as_obj = {}
		for category in catstr.split(',')
			as_obj[category] = true
		state[dim] = as_obj
	return state

update_url_filtering = (newopts) ->
	state = {}
	# Convert to a bit nicer list-format
	for dim, categories of newopts
		state[dim] = (cat for cat of categories).join(',')
	
	current = get_url_filtering()
	newstate = _.extend current, state
	window.location.hash = $.param newstate

</script>

</body>
</html>
