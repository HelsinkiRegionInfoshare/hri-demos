<meta charset="utf-8">
<script type="text/javascript" src="../vendor/coffee-script.js"></script>
<script type="text/javascript" src="../vendor/jquery-1.11.0.js"></script>
<script type="text/javascript" src="../vendor/underscore.js"></script>

<link rel="stylesheet" href="../vendor/leaflet.css" />
<script src="../vendor/leaflet.js"></script>
<script src="../vendor/proj4.js"></script>
<script src="../vendor/proj4leaflet.js"></script>
<script src="../vendor/leaflet-dvf.js"></script>
<script type="text/coffeescript" src="hel_map.coffee"></script>

<script src="../vendor/d3.v3.min.js"></script>
<script src="../vendor/dimple.v2.1.0.js"></script>

<script type="text/javascript" src="../vendor/spin.js"></script>
<script type="text/javascript" src="../vendor/jquery.spin.js"></script>

<link rel="stylesheet" href="../vendor/jquery.powertip/jquery.powertip.css" />
<script type="text/javascript" src="../vendor/jquery.powertip/jquery.powertip.js"></script>

<script type="text/javascript" src="../vendor/chosen/chosen.jquery.js"></script>
<link rel="stylesheet" href="../vendor/chosen/chosen.css" />

<script type="text/coffeescript" src="statsmap.coffee"></script>
<script type="text/coffeescript" src="blockhist.coffee"></script>

<style type="text/css">
#map_colormap_legend .colormap_scale {
	padding: 0; margin: 0;
}

body, html {
	margin: 0; padding: 0;
}

#map_colormap_legend {
	margin: 0; padding: 0;
	font-size: small;
	display: none;
}

#grid_container {
	position: absolute;
	display: table;
	width: 100%;
	height: 100%;
}

#grid_container table {
	width: 100%;
	height: 100%;
	margin: 0; padding: 0;
}

svg * {
	font-size: 14px !important;
}

#map path {
	transition: fill linear 1.0s;
	transition: stroke linear 0.1s;
}

#histogram {
	position: relative;
	box-sizing: border-box;
	display: flex;
	padding-left: 80px;
}

#histogram .histogram_canvas {
	border-bottom: 1px solid black;
}

#histogram .bin {
	left: 0;
	right: 0;
	background-color: rgba(255, 255, 255, 0.0)
	box-sizing: border-box;
	box-shadow: 0px 0px 0px 2px rgba(255, 255, 255, 0.5) inset;
	cursor: pointer;
	transition: all 1s ease-in-out;
	transition: z-index 0s;
	transition: box-shadow 0s;
}

#histogram .bin:hover {
	box-shadow: 0px 0px 0px 2px rgba(255, 255, 255, 0.5) inset, 0px 0px 2px 4px rgba(255, 255, 255, 0.6);
	z-index: 3;
}

#histogram .selected-bin {
	box-shadow: 0px 0px 1px 2px rgba(0, 0, 0, 0.75), 0px 0px 0px 2px rgba(255, 255, 255, 0.5) inset;
	z-index: 2;
}

#histogram .selected-bin:hover {
	box-shadow: 0px 0px 2px 4px rgba(50, 50, 50, 0.75), 0px 0px 0px 2px rgba(255, 255, 255, 0.5) inset;
	z-index: 3;
}

#area_label, #variable_label {
	font-size: 16px;
}

#variable_label .chosen-container {
	width: 300px !important;
	font-size: 16px !important;
}

</style>

<!-- Todo: get rid of this table mess -->
<table id="grid_container">
<tr height="0%"><td><h3 style="margin: 0; display: inline;"><span id="variable_label"></span> <span id="area_label"></span></h3></td></tr>
<tr>

<td><table>
<tr height="100%"><td height="100%" width="50%" id="map"></td></tr>
<tr><td id="map_colormap_legend"></td></tr>
</table></td>

<td width="50%" id="timeseries_container">
 <table>
 <tr><td height="50%"><div id="histogram" style="width: 100%; height: 100%"></div></td></tr>
 <tr><td height="50%"><svg id="timeseries" style="width: 100%; height: 100%"></svg></td></tr>
</td>

</tr></table>


<script type="text/coffeescript">

geojson_area_id = (feature) -> parseInt feature.properties.tunnus

objectify_spec = (spec) ->
	objectify_list = (list) ->
		for value in list
			if _.isObject(value) and 'id' of value
				list[value.id] = value
			objectify_spec value

	objectify_object = (spec) ->
		for key, value of spec
			objectify_spec value
	
	if _.isArray spec
		objectify_list spec
	if _.isObject spec
		objectify_object spec
	
	return spec

class AluesarjatIndicator
	@_get_area_id = (area_code) ->
		numeric = parseInt area_code[area_code.length-3...]
		if numeric != 0
			return numeric
		else
			return area_code
	
	@New: (args...) ->
		$.getJSON(@get_base_url())
		.then (spec) =>
			objectify_spec spec
			self = new @(spec, args...)

	constructor: (@metadata) ->
		@base_url = @metadata._links.self.href
		@_area_id_map = {}
		@area_filter = (area_id) -> true
		for area in @metadata.dimensions.alue.categories
			@_area_id_map[@constructor._get_area_id area.id] = area

	get_reference_area: => @metadata.dimensions.alue.categories[0].id

	get_area_label: (area_id) =>
		category = @_area_id_map[area_id]
		return category.label ? category.id

class AluesarjatSimpleShareIndicator extends AluesarjatIndicator
	@all_id: 'all'
	@formatter: d3.format(".3p")

	@get_base_url: ->
		return "#{@dataset_url}filter&#{@field_id}=#{@all_id},#{@subset_id}/"
	
	get_reference_year: =>
		current = "#{new Date().getFullYear()}"
		cats = @metadata.dimensions.vuosi.categories
		for cat in cats
			# TODO: HACK! There's an undefined for some reason
			if not cat
				continue
			if cat.id == current
				return cat
		return cats[cats.length-1]

	get_year_data: =>
		year = @get_reference_year().id
		if not year
			asdfasdfasf
		cls = @constructor
		data_promise = $.getJSON "#{cls.get_base_url()}filter&vuosi=#{year}/group_for_columns?as_values=#{cls.field_id},value"
		data_promise.then (raw_data) =>
			data = []
			for grp in raw_data
				area_id = cls._get_area_id(grp.alue)
				if not @area_filter area_id
					continue

				field_row = grp[cls.field_id]
				subset = parseFloat grp.value[field_row.indexOf(cls.subset_id)]
				all = parseFloat grp.value[field_row.indexOf(cls.all_id)]
				data.push [area_id, subset/all]
			return data: data
	
	get_timeseries_data: (areas) =>
		areas = (@_area_id_map[a].id for a in areas)
		cls = @constructor
		valcols = "#{cls.field_id},value".split(',')
		data_promise = $.getJSON "#{cls.get_base_url()}filter&alue=#{areas.join ','}/group_for_columns?as_values=#{valcols.join ','}"
		data_promise.then (raw_data) ->
			datasets = ([] for area in areas)
			d_idx = {}
			for [area, d] in _.zip(areas, datasets)
				d_idx[area] = d
				
			for grp in raw_data
				field_row = grp[cls.field_id]
				subset = parseFloat grp.value[field_row.indexOf(cls.subset_id)]
				all = parseFloat grp.value[field_row.indexOf(cls.all_id)]
				d_idx[grp.alue].push [parseInt(grp.vuosi), subset/all]
				d_idx[grp.alue].area = cls._get_area_id grp.alue
			
			return datasets: datasets

class WomenShare extends AluesarjatSimpleShareIndicator
	@dataset_url: "http://dev.hel.fi/stats/resources/aluesarjat_a01s_hki_vakiluku/filter&ika=99V&aidinkieli=all/"
	@field_id: "sukupuoli"
	@subset_id: "2"
	@title: "Naisten osuus"
	
class ForeignShare extends AluesarjatSimpleShareIndicator
	@dataset_url: "http://dev.hel.fi/stats/resources/aluesarjat_a03s_hki_vakiluku_aidinkieli/"
	@field_id: "aidinkieli"
	@subset_id: "3"
	@title: "Ulkomaankielisten osuus"

class SingleShare extends AluesarjatSimpleShareIndicator
	@dataset_url: "http://dev.hel.fi/stats/resources/aluesarjat_a01s_hki_asuntokunnat/"
	@field_id: "henkiloluku"
	@subset_id: "1"
	@title: "Yksinasuvien osuus"

class BirthRate extends AluesarjatSimpleShareIndicator
	@dataset_url: "http://dev.hel.fi/stats/resources/aluesarjat_a01hkis_vaestoennuste/"
	@field_id: "ika"
	@subset_id: "00V"
	@all_id: "99V"
	@title: "Syntyvyys"
	


available_indicators = [WomenShare, ForeignShare, SingleShare, BirthRate]

GEOSERVER_BASE_URL = "http://geoserver.hel.fi/geoserver/"



###
$(statsmap).on "area-mouseover", (area_id, value) ->
	mapel.data 'powertipjq', $("<div>#{value}</div>")
	mapel.powerTip "show"

$(statsmap).on "area-mouseout", ->
	mapel.powerTip "hide"
	# Without this the powertip won't change
	# the contents.
	$.powerTip.hide()
###

# Fetch the area polygons in GeoJSON format using WFS
wfs_url = GEOSERVER_BASE_URL + "wfs/"
request_parameters = {
	# Specify the dataset to use
	typeName: 'hel:osaalue'
	# Standard WFS request parameters
	srsName: 'EPSG:4326'
	service: 'WFS'
	version: '1.1.0'
	request: 'GetFeature'
	outputFormat: 'application/json'
}

request_options =
		data: request_parameters
polygons_promise = $.ajax wfs_url, request_options

start_controller = (polygons) ->
	ctrl = new _Controller(polygons)
	ctrl.set_dataset available_indicators[0]
	.then =>
		ctrl.statsmap.fit_data_bounds()
		return ctrl

autoscale_fix = (axis) ->
	min = Infinity
	max = -Infinity
	for row in axis.chart._getAllData()
		x = row[axis.measure]
		min = Math.min x, min
		max = Math.max x, max
	
	axis.overrideMin = min
	axis.overrideMax = max

class _Controller
	constructor: (polygons) ->
		dataset = available_indicators[0]
		# Hack!
		dropdown = $("<select>").appendTo $("#variable_label")
		for ind, i in available_indicators
			dropdown.append $ """
			<option value="#{i}">#{ind.title}</option>
			"""
		dropdown.chosen()
		dropdown.change =>
			@set_dataset available_indicators[dropdown.val()]
		
		@area_selection = []

		mapstuff = hel_leaflet_map "map"
		@$statsmap_el = $("#map")
		map = mapstuff.map
		@statsmap = new StatsMap map,
			legend_el: "#map_colormap_legend"
		
		
		shaped_areas = {}
		for feature in polygons.features
			shaped_areas[geojson_area_id feature] = true
		@area_filter = (a) -> a of shaped_areas

		@statsmap.set_polygons polygons, geojson_area_id
		
		toggle_area_selection = (area_id, value) =>
			return if isNaN value
			if @area_selection and @area_selection[0] == area_id
				sel = []
			else
				sel = [area_id]

			@set_area_selection sel

		$(@statsmap).on "area-click", (e, area_id, value) =>
			toggle_area_selection area_id, value
			
		el = d3.select("#timeseries")
		chart = new dimple.chart el, []
		chart.x_axis = chart.addMeasureAxis('x', 'Vuosi')
		chart.x_axis.ticks = 5
		chart.y_axis = chart.addMeasureAxis('y', 'value')
		chart.y_axis.ticks = 5
		chart.setMargins 80, 0, 20, 40
		# Uglyuglyugly, see
		# https://github.com/PMSI-AlignAlytics/dimple/issues/99
		chart.y_axis._getFormat = => @dataset.formatter
		chart.x_axis._getFormat = => (x) -> x
		chart.addSeries(["Vuosi", "Alue"], dimple.plot.line)
		chart.addLegend("0%", "10px", "100%", null, "right")
		@timeseries = chart
		
		@histogram = new BlockHist $("#histogram")
		@histogram.el.on "click", ".bin", (e) ->
			el = $ e.target
			toggle_area_selection el.data("bin-label"), el.data("bin-value")
		
		@$timeseries_el = $("#timeseries_container")
		$(window).resize =>
			@timeseries.draw 0, true
		
		
		
		@container_el = $("#grid_container")
		@container_el.powerTip
			followMouse: true
			manual: true
			closeDelay: 0
			fadeOutTime: 0
			fadeInTime: 0

		
		show_tooltip = (area_id, value) =>
			area = @stats.get_area_label area_id
			@container_el.data 'powertipjq', $(
				"""
				<dl>
				<dt>#{area}</dt>
				<dd>#{@stats.constructor.formatter value}</dd>
				</dl>
				"""
				)
			@container_el.powerTip "show"
		
		hide_tooltip = =>
			@container_el.powerTip "hide"; $.powerTip.hide()
		
		$(@statsmap).on "area-mouseover", (e, area_id, value) =>
			show_tooltip area_id, value

		$(@statsmap).on "area-mouseout", ->
			hide_tooltip()

		@histogram.el.on "mouseover", ".bin", (e) =>
			el = $ e.target
			show_tooltip el.data("bin-label"), el.data("bin-value")

		@histogram.el.on "mouseout", ".bin", ->
			hide_tooltip()
		
		
	
	set_dataset: (@dataset) =>
		@dataset.New().then @_new_stats

	_new_stats: (@stats) =>
		@stats.area_filter = @area_filter
		@area_id_map = {}
		
		$.when(@_update_area_stats(), @_update_timeseries()).then =>
			@statsmap.render()
			# TODO: Ugly hacks
			@histogram.colormap = @statsmap.colormap
			@histogram.formatter = @stats.constructor.formatter
			for area in @area_selection
				@histogram.el.find("[data-bin-label='#{area}']").addClass("selected-bin")
			@histogram.draw()
	
	set_area_selection: (selection) =>
		@area_selection = selection
		@statsmap.set_selection @area_selection
		
		@histogram.el.find(".bin").removeClass("selected-bin")
		for area in selection
			@histogram.el.find("[data-bin-label='#{area}']").addClass("selected-bin")
		@_update_timeseries()

	_update_area_stats: =>
		p = @stats.get_year_data()
		p.then (data) =>
			@statsmap.set_data data.data, @dataset.formatter
			[areas, values] = _.zip data.data...
			@histogram.set_data values, areas
			
	
	_update_timeseries: =>
		@$timeseries_el.spin()
		areas = [@stats.get_reference_area()].concat(@area_selection)
		# Hack!
		$("#area_label").text @stats.get_area_label areas[areas.length-1]
		p = @stats.get_timeseries_data areas

		is_invalid = (x) -> not x? or isNaN x
		p.then (data) =>
			entries = []
			for rows in data.datasets
				for [x, y] in rows
					entry = {}
					continue if is_invalid(x) or is_invalid(y)
					entry["Vuosi"] = x
					# Abstraction leakedileaks
					entry["Alue"] = @stats.get_area_label rows.area
					entry[@stats.constructor.title] = y
					entries.push entry
			
			@timeseries.y_axis.measure = @stats.constructor.title
			@timeseries.data = entries
			autoscale_fix @timeseries.x_axis
			autoscale_fix @timeseries.y_axis
			@$timeseries_el.spin(false)
			@timeseries.draw(300)
		

polygons_promise
.then (polygons) ->
	start_controller polygons
.then (controller) ->
	#setTimeout (-> controller.set_dataset WomenShare), 1000

</script>
